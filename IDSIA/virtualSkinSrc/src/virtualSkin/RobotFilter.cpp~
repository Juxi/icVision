/*
 * Copyright (C) 2010 Gregor Kaufmann
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
 *
 */

/** @file RobotFilter.cpp Implementation file for the RobotFilter class.
 *
 * Version: $Rev$
 *
 * $Date$
 *
 */

#include "RobotFilter.h"

#include "StateObserver.h"
#include "CallObserver.h"
#include "ResponseObserver.h"
#include "constants.h"

#include <yarp/os/all.h>
#include <yarp/dev/all.h>
#include <iostream>

static int tryBodyPart(QString robotName, QString partName) {
	int failure = 0;
	bool ok = false;
	
	QString remoteBaseName = "/" + robotName + "/" + partName;
	QString localBaseName = remoteBaseName + "/control";

    yarp::os::Property options;
	options.put("robot", robotName.toStdString().c_str());
    options.put("device", "remote_controlboard");
    options.put("local", localBaseName.toStdString().c_str());
    options.put("remote", remoteBaseName.toStdString().c_str());
	
	std::cout << std::endl << "creating PolyDriver" << std::endl;
	//std::cout << "  robot: " << options.find("robot").asString() << std::endl;
	//std::cout << "  device: " << options.find("device").asString() << std::endl;
	//std::cout << "  local: " << options.find("local").asString() << std::endl;
	//std::cout << "  remote: " << options.find("remote").asString() << std::endl << std::endl;
	yarp::dev::PolyDriver robotDriver(options);
	if (!robotDriver.isValid()) {
		std::cout << "...failed" << std::endl;
		return failure;
	}

    // connect controllers to the simulation
	std::cout << "  connecting position controller" << std::endl;
    yarp::dev::IPositionControl *pos;
	ok = robotDriver.view(pos);
    if (!ok) {
		std::cout << "...failed" << std::endl;
        return failure;
    }
	
	// do i really need to do this?
	std::cout << "  connecting velocity controller" << std::endl;
    yarp::dev::IVelocityControl *vel;
    ok = robotDriver.view(vel);
    if (!ok) {
		std::cout << "...failed" << std::endl;
        return failure;
    }

    // get the number of axes
    int numberOfAxes = 0;
    pos->getAxes(&numberOfAxes);
	//std::cout << "position controller has " << numberOfAxes << "axes" << std::endl;

    robotDriver.close();

    return numberOfAxes;
}

RobotFilter::RobotFilter() : isOpen(false), /*emitCollisions(true),*/ robot(NULL), cbFilters(), stateObservers(), callObservers(), responseObservers() {
	// No special action to take for construction
}

RobotFilter::~RobotFilter() {
	if (true == isOpen) {
		close();
	}
}

bool RobotFilter::open() {
	if (true == isOpen) {
		close();
	}
	std::cout << "Starting robot filter." << std::endl;

    // check whether a network is available
    if (false == yarp::os::Network::checkNetwork()) {
		std::cout << "network unavailable..." << std::endl;
    	return false;
    }
	
	// check whether there is a robotModel
	if ( !robot ) {
		std::cout << "no robot model has been set...  you must call setRobot(Robot&) before open()" << std::endl;
		return false;
	}

	// Get the name of the robot. It is used as the base of the YARP port
	// name of the ports the ControlBoardFilter are going to connect to
	const QString deviceBaseName(robot->getName());
	const QString filterBaseName(robot->getName() + "F");

	// For each branch
	//   control the number of axes
	//   create a ControlBoardFilter
	//   create an observer for the encoder readings
	//   create an observer for the rpc responses
	// TODO: create observers for commands
	yarp::os::ControlBoardFilter *p_cbf;
	StateObserver *p_so;
	CallObserver *p_co;
	ResponseObserver *p_ro;
	QString targetName;
	QString filterName;
	int yarpNumAxes,modelNumAxes;

	const QString robotName = robot->getName();
	//std::cout << "Connecting to robot: " << robotName.toStdString() << std::endl;
	//std::cout << "  " << robot.getNumBranches() << " branches" << std::endl;

	for (int bodyPart = 0; bodyPart < robot->getNumBodyParts(); bodyPart++) {
		std::cout << std::endl << "----------------------------------------------------------------" << std::endl;
		
		const QString* partName = robot->getPartName(bodyPart);
		std::cout << "connecting to " << robotName.toStdString() << ":" << partName->toStdString() << std::endl;
		
		modelNumAxes = robot->getNumMotors(bodyPart);
		yarpNumAxes = tryBodyPart(robotName, *partName);
		if (modelNumAxes != yarpNumAxes) {
			std::cout << "ERROR: NUMBER OF AXES DOES NOT MATCH!" << std::endl;
			std::cout << "    modelNumAxes: " << modelNumAxes << std::endl;
			std::cout << "    yarpNumAxes: " << yarpNumAxes << std::endl;
			close();
			return false;
		}
		else
		{
			
			std::cout << "Creating ControlBoardFilter for " << robot->getPartName(bodyPart)->toStdString() << std::endl;
			p_cbf = new yarp::os::ControlBoardFilter();
			filterName = "/" + robot->getName() + "F/" + *(robot->getPartName(bodyPart));
			targetName = "/" + robot->getName() + "/" + *(robot->getPartName(bodyPart));
			if (true == p_cbf->open(filterName.toStdString().c_str(),
									targetName.toStdString().c_str())) {

				std::cout << "  ControlBoardFilter opened" << std::endl;

				cbFilters.append(p_cbf);

				// create and set state observer
				p_so = new StateObserver(this, bodyPart);
				
				//p_so = new StateObserver(robot, bodyPart);
				p_cbf->setStateObserver(p_so);
				stateObservers.append(p_so);

				std::cout << "  StateObserver set" << std::endl;

				// create and set call observer
				p_co = new CallObserver(robot, bodyPart);
				p_cbf->setCallObserver(p_co);
				callObservers.append(p_co);

				std::cout << "  CallObserver set" << std::endl;

				// create and set response observer
				p_ro = new ResponseObserver(robot, bodyPart);
				p_co->setResponseObsever(p_ro);
				p_cbf->setResponseObserver(p_ro);
				responseObservers.append(p_ro);

				std::cout << "  ResponseObserver set" << std::endl;	
			} else {
				std::cout << "Failed to find yarp target port: " << targetName.toStdString() << std::endl;

				delete p_cbf;
				close();
				return false;
			}
			 
		}	
	}
	
	isOpen = true;
	targetPose.resize(robot->getNumBodyParts());
	statusPort.start();
	statusPort.setBottle( Bottle("1") );
	
	return true;
}

void RobotFilter::close() {
	
	statusPort.stop();
	
	// remove all observers from the ControlBoardFilters, close the filters
	// and delete them
	QVector<yarp::os::ControlBoardFilter*>::const_iterator cbfIter;
	for (cbfIter = cbFilters.begin(); cbfIter != cbFilters.end(); ++cbfIter) {
		(*cbfIter)->setResponseObserver(NULL);
		(*cbfIter)->setCallObserver(NULL);
		(*cbfIter)->setCommandObserver(NULL);
		(*cbfIter)->setStateObserver(NULL);
		(*cbfIter)->close();
		yarp::os::ControlBoardFilter *cbf = *cbfIter;
		delete cbf;
	}
	cbFilters.clear();

	// delete all observers
	QVector<StateObserver*>::const_iterator i;
	for (i = stateObservers.begin(); i != stateObservers.end(); ++i) {
		delete (*i);
	}
	stateObservers.clear();
	QVector<CallObserver*>::const_iterator j;
	for (j = callObservers.begin(); j != callObservers.end(); ++j) {
		delete (*j);
	}
	callObservers.clear();
	QVector<ResponseObserver*>::const_iterator k;
	for (k = responseObservers.begin(); k != responseObservers.end(); ++k) {
		delete (*k);
	}
	responseObservers.clear();

	isOpen = false;
}

void RobotFilter::takeControl() {
	
	//statusPort.setClosed();
	statusPort.setBottle( Bottle("0") );
	
	// rpc command to send to the robot
	yarp::os::Bottle stop_command;
	stop_command.addVocab(VOCAB_SET);
	stop_command.addVocab(VOCAB_STOPS);
	
	for ( int bodyPart = 0; bodyPart < robot->getNumBodyParts(); bodyPart++) {
			cbFilters.at(bodyPart)->cutConnection(true);		// take control away from the user
			cbFilters.at(bodyPart)->injectCall(stop_command);	// stop the robot
	}
	
	// turn off response to collision
	emit haveControl();
	std::cout << "ROBOT FILTER ALL STOP!!!" << std::endl;
	
	
	yarp::os::Bottle rewind;
	QVector<qreal>::const_iterator joint;				// to iterate through joints in a body part
		
	for ( int bodyPart = 0; bodyPart < robot->getNumBodyParts(); bodyPart++) {
		
		// build a position move bottle
		rewind.clear();
		rewind.addVocab(VOCAB_SET);
		rewind.addVocab(VOCAB_POSITION_MOVES);
		yarp::os::Bottle& newPose = rewind.addList();
		
		// get the desired pose from the pose buffer for this body part
		targetPose.replace(bodyPart, stateObservers.at(bodyPart)->nonCollidingPose());
		
		// re-initialize the whole pose buffer using the non-colliding pose
		stateObservers.at(bodyPart)->initPoseBuffer( targetPose.at(bodyPart) );
		
		// put the desired pose into the position move bottle
		for ( joint = targetPose.at(bodyPart).begin(); joint != targetPose.at(bodyPart).end(); ++joint ) {
			newPose.addDouble(*joint);
		}
		
		// move the robot back to a non-colliding pose
		//std::cout << "Sending Rewind Command :" << robot->getPartName(bodyPart)->toStdString() << " : " << rewind.toString() << std::endl;
		cbFilters.at(bodyPart)->injectCall(rewind);
	}
	
	// wait for the robot to reach the specified position... then return control to the user
	start();
}
void RobotFilter::run() {
	
	bool poseReached;
	time_t startTime = time(NULL);
	QVector<qreal>::const_iterator jointA,jointB;
	
	for ( int bodyPart = 0; bodyPart < robot->getNumBodyParts(); bodyPart++) {
		
		// get the robot's current pose from the pose buffer
		const QVector<qreal>& currentPose = stateObservers.at(bodyPart)->currentPose();
		
		//std::cout << "-------------------------------------------" << std::endl;
		//std::cout << "Watching Position :" << robot->getPartName(bodyPart)->toStdString() << std::endl;
		//std::cout << "    current pose size: " << currentPose.size() << std::endl;
		//std::cout << "    target pose size: " << targetPose.at(bodyPart).size() << std::endl;
		
		// wait for the robot to reach the target pose
		do {
			usleep(3*YARP_PERIOD);
			poseReached = true;
			
			for ( jointA  = targetPose.at(bodyPart).begin(), jointB  = currentPose.begin();
				  jointA != targetPose.at(bodyPart).end() && jointB != currentPose.end();   ++jointA, ++jointB )
			{
				if ( qAbs(*jointA-*jointB) > NEGLIGIBLE_ANGLE )
				{
					//std::cout << time(NULL) - startTime << "s A-B = " << qAbs(*jointA-*jointB) << std::endl;
					poseReached = false;
				}
			}
			
			if ( time(NULL) - startTime >= POSITION_MOVE_TIMEOUT ) {
				std::cout << "Position move for collision recovery timed out!" << std::endl;
				break;
			}
			
		} while ( poseReached == false );
		if ( time(NULL) - startTime >= POSITION_MOVE_TIMEOUT ) break;
	}

	// reopen the filter... 
	for ( int bodyPart = 0; bodyPart < robot->getNumBodyParts(); bodyPart++ ) {
		cbFilters.at(bodyPart)->cutConnection(false);
	}
	
	//emit returnControl();
	//statusPort.setOpen();
	statusPort.setBottle( Bottle("1") );
	emit returnControl();
	std::cout << "Control Restored" << endl;
}
